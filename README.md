# Money Manage App

## Note for Contributors

This project is a [mono-repo](https://en.wikipedia.org/wiki/Monorepo) containing both front-end and backend code bases managed using npm's [workspaces](https://docs.npmjs.com/cli/v7/using-npm/workspaces#description). It's a bit of different approach then what I've seen out in the community so far, so we'll cover just the basics that would be important for anyone contributing to this project.

The problem arises in the poly-repo approach due to them sharing the same root directory. While our version control is treating it as one repo, our dependency management is not.

As you see below, this is a common structure of a poly repo. It's more of a hybrid though. The version control exists in the root directory with a `readme.md` file. Then we have two different packages with their separate dependencies nested in their respective folders (client and server).

```bash
DIR_ROOT
|   readme.md
+---.git
+---client
|   |   package.json
|   +---node_modules
|   +---public
|   \---src
|           index.js
\---server
    |   package.json
    +---node_modules
    \---src
            index.js
```

There's nothing wrong with this structure, it's a valid separation of concern.
But as you implement a [CI/CD](https://en.wikipedia.org/wiki/CI/CD) pipeline and build for deployment, there are additional factors to consider. Especially depending your final host cloud that the production application ultimately lives on.

In our case, we will be deploying the repository into a single container through all environments. So it makes sense to utilize the mono-repo method in are dependency management.

Below is the basic structure of our project now. It's mostly the same except a couple things.

```bash
DIR_ROOT
|   readme.md
|   package.json # new
+---node_modules # new
+---.git
+---client
|   |   package.json
|   +---node_modules
|   +---public
|   \---src
|           index.js
\---server
    |   package.json
    +---node_modules
    \---src
            index.js
```

As you can see we still have our nested packages along with their dependencies folders. But now we have a package and a dependency folder at the root level as well. We still have our separation of concern for each code base, but now all our dependencies actually live in live in the upper most folder and the nested dependency folders only contain references to their needed dependencies listed from their packages.

A simple summary of what is happening now. In our package at the root of the project we have a setting [`"workspaces": []`](https://docs.npmjs.com/cli/v7/using-npm/workspaces#description), that references the folders containing the other packages.

```json
// ~/package.json
"workspaces": ["client", "server"]
```

Our other packages do not change, but the package-lock file generated by our package manager (NPM) contains the references to the location of their dependencies. We don't need to worry about the code in them, only that when we install our dependencies we run the command from the root of the project.

---

> ### What does all this mean for the developer?

A couple things will need to be done differently now, but it's actually a simpler process then before.

The main thing is that there's no need to change working directories in the terminal now when executing any node scripts or npm commands.

## What has changed

### 1. Installing base node dependencies

Under the previous structure we would open our project in the terminal at the root directory and run a series of commands

```bash
#!~/ 
cd server 
npm install 
cd ../client 
npm install
```

or this

```bash
#!~/ 
cd server && npm install
cd client && npm install
```

Which was kinda much for a simple task.

Now we only need to run one command from the root of the project.

#### To install node dependencies just run command from the root of the project

```bash
#!~/ 
npm install
```

It's that simple now.

> __warning:__
>_if `npm install` is ran from either of the nested directories containing the the package it will overwrite the reference in the package-lock_
> _in order to fix you'll just need to go back to the root directory and run `npm install` again_

### 2. Adding new dependencies to one of the project's dependencies

Much like the install dependency process has changed, adding dependencies to one of the project's will be done kind of the same way, from the root directory to the project. The command syntax `npm add <module_name> -w <workspace_name>`

example

```bash
#!~/ 
npm add axios -w client
```

The most notable thing here is the `-w` flag, which defines that we want to add the dependency to a workspace and after we use the workspace name to tell it which one to install to.

>__warning:__ _omitting the `-w` flag and workspace name will cause NPM to install the dependency to the root level package and may not work properly during runtime._
> _if this happens you will need to remove it from the root package by running `npm uninstall <module_name>` then run the `npm add` command again with the workspace flag `-w` with the desired location.

### 3. Creating node scripts

Inside each package there is still our scripts to run our applications accordingly. For the projects themselves that will remain the same. But in addition to adding any new script to it's project we will need to also create a script in the root package. The script that we create in the root package will be the one that we actually want to run.

While we could `cd` into the project location and `npm run` the desire script. It kind of steps away from the structure we've been working with at this point.

Here is an example of how we'll configure that process.

In our `~/client/package.json` file we have the following scripts
![client package json][client package scripts]

and in our `~/server/package.json` file we have the following scripts
![server package json][server package scripts]

then finally in our `~/package.json` file we have the following scripts
![root package json][root package scripts]

As we can see we have our scripts defined to their respective project locations. This is necessary because of their individual dependencies, such as our client project using `react-scripts` to produce our outputs. If we were to try and call `react-scripts` from the root directory it would throw an error. Thats because the module is out of scope. The same would happen for any other scope dependency. (expect node that is global)

So lastly we have our scripts defined in our root package. This should speak for itself, but we'll briefly cover it.
The scripts defined here simply tell node to execute the scripts that are in another location.

The `"start:client"` script may look a little weird because of the `--prefix` flag. Here we are just prepending the client folder before executing the `npm run start` command. This is the same as running `cd client && npm run start` the both do the same thing in the end. But with using NPM's API CLI we can leverage some other features, that's all.

---

## Development

[client package scripts]: ./assets/snippet1.png "~/client/package.json"
[server package scripts]: ./assets/snippet2.png "~/server/package.json"
[root package scripts]: ./assets/snippet3.png "~/package.json"
